\input texinfo

@c data-frame.texi --- Reference manual

@c Copyright (C) 2019-2022 Steve Nunez

@c This file is part of Data Frame.

@c This program is distributed under the terms of the Microsoft Public
@c License.


@c Commentary:

@c Generated automatically by Declt version 4.0 beta 2 "William Riker"
@c on Wed Jul 20 10:54:46 2022 GMT+8.


@c ====================================================================
@c Header
@c ====================================================================
@c %**start of header
@setfilename data-frame.info
@settitle The Data Frame Reference Manual
@afourpaper
@documentencoding UTF-8
@c %**end of header



@c ====================================================================
@c Format Specific Tweaks
@c ====================================================================
@tex
%% Declt uses several Unicode characters to "reveal" blanks. This
%% works fine in HTML or Info output, but TeX will have problems with
%% these. The code below translates those characters to something that
%% TeX can handle.

%% U+23B5 (Bottom Square Bracket), used to reveal white spaces, is
%% translated to its Computer Modern teletype version.
\DeclareUnicodeCharacter{23B5}{{\tt\char'040}}

%% U+21B5 (Downwards Arrow With Corner Leftwards), used to reveal
%% carriage returns, is translated to \hookleftarrow in math mode.
\DeclareUnicodeCharacter{21B5}{\ensuremath\hookleftarrow}

%% U+21E5 (Rightwards Arrow To Bar), used to reveal tabs, is
%% translated to something that looks similar, based on a rightarrow
%% and a vertical bar from the math extension font.
\DeclareUnicodeCharacter{21E5}{%
  \ensuremath{\rightarrow\kern-.5em\mathchar\"130C}}


%% Declt uses several Unicode characters to replace "fragile" ones in
%% anchor names and references. These characters are chosen to resemble
%% the original ones, without interfering with Info syntax. In TeX
%% however, we can switch them back to the original versions, because
%% cross-references are done differently. In theory, I think we could do
%% something similar for HTML output (again, only the Info syntax poses
%% problems), but I don't know how to do something similar to what's
%% below.

%% U+2024 (One Dot Leader) replaces periods.
\DeclareUnicodeCharacter{2024}{.}

%% U+2236 (Ratio) replaces colons.
\DeclareUnicodeCharacter{2236}{:}

%% U+2768 (Medium Left Parenthesis Ornament) replaces left parenthesis.
\DeclareUnicodeCharacter{2768}{(}

%% U+2769 (Medium Right Parenthesis Ornament) replaces right parenthesis.
\DeclareUnicodeCharacter{2769}{)}

%% U+214B (Turned Ampersand) replaces ampersands.
\DeclareUnicodeCharacter{214B}{&}

%% U+2216 (Set Minus) replaces backslashes.
\DeclareUnicodeCharacter{2216}{\char"5C}

%% The following ones are already defined in texinfo.tex so we have nothing
%% more to do:
%% U+201A (Single Low-9 Quotation Mark) replaces commas.
%% U+2205 (Empty Set) replaces empty symbol names.

@end tex



@c ====================================================================
@c Settings
@c ====================================================================
@setchapternewpage odd
@documentdescription
The Data Frame Reference Manual, version 1.0.0.
@end documentdescription



@c ====================================================================
@c New Commands
@c ====================================================================

@c ---------------
@c Indexing macros
@c ---------------

@c Packages
@macro packageindex{name}
@tpindex \name\
@tpindex @r{Package, }\name\
@end macro

@c Systems
@macro systemindex{name}
@tpindex \name\
@tpindex @r{System, }\name\
@end macro

@c Modules
@macro moduleindex{name}
@tpindex @t{\name\}
@tpindex Module, @t{\name\}
@end macro

@c Files
@macro fileindex{name}
@tpindex @t{\name\}
@tpindex File, @t{\name\}
@end macro

@c The following macros are meant to be used within @defxxx environments.
@c Texinfo performs half the indexing job and we do the other half.

@c Constants
@macro constantsubindex{name}
@vindex @r{Constant, }\name\
@end macro

@c Special variables
@macro specialsubindex{name}
@vindex @r{Special Variable, }\name\
@end macro

@c Symbol macros
@macro symbolmacrosubindex{name}
@vindex @r{Symbol Macro, }\name\
@end macro

@c Slots
@macro slotsubindex{name}
@vindex @r{Slot, }\name\
@end macro

@c Macros
@macro macrosubindex{name}
@findex @r{Macro, }\name\
@end macro

@c Compiler Macros
@macro compilermacrosubindex{name}
@findex @r{Compiler Macro, }\name\
@end macro

@c Functions
@macro functionsubindex{name}
@findex @r{Function, }\name\
@end macro

@c Methods
@macro methodsubindex{name}
@findex @r{Method, }\name\
@end macro

@c Generic Functions
@macro genericsubindex{name}
@findex @r{Generic Function, }\name\
@end macro

@c Setf Expanders
@macro expandersubindex{name}
@findex @r{Setf Expander, }\name\
@end macro

@c Method Combinations
@macro combinationsubindex{name}
@findex @r{Method Combination, }\name\
@end macro

@c Conditions
@macro conditionsubindex{name}
@tpindex @r{Condition, }\name\
@end macro

@c Structures
@macro structuresubindex{name}
@tpindex @r{Structure, }\name\
@end macro

@c Types
@macro typesubindex{name}
@tpindex @r{Type, }\name\
@end macro

@c Classes
@macro classsubindex{name}
@tpindex @r{Class, }\name\
@end macro



@c ====================================================================
@c Info Category and Directory
@c ====================================================================
@dircategory Lisp-Stat
@direntry
* Data Frame Reference Manual: (data-frame). The Data Frame Reference Manual.
@end direntry



@c ====================================================================
@c Copying
@c ====================================================================
@copying
@quotation
Copyright @copyright{} 2019-2022 Steve Nunez

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying'' is included exactly as in the original.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be translated as well.
@end quotation
@end copying



@c ====================================================================
@c Title Page
@c ====================================================================
@titlepage
@title The Data Frame Reference Manual
@subtitle Data frames for Common Lisp, version 1.0.0

@author Steve Nunez <@email{steve@atchar{}symbolics.tech}>

@page
@quotation
This manual was generated automatically by Declt 4.0b2.
@end quotation
@vskip 0pt plus 1filll
@insertcopying
@end titlepage



@c ====================================================================
@c Table of Contents
@c ====================================================================
@contents



@c ====================================================================
@c Top
@c ====================================================================
@ifnottex
@node Top, Copying, (dir), (dir)
@top The Data Frame Reference Manual
This is the Data Frame Reference Manual, version 1.0.0,
generated automatically by Declt version 4.0b2.

@menu
* Copying:: The Microsoft Public License
* Systems:: The systems documentation
* Files:: The files documentation
* Packages:: The packages documentation
* Definitions:: The symbols documentation
* Indexes:: Concepts, functions, variables and data types
@end menu

@insertcopying
@end ifnottex



@c ====================================================================
@c Copying
@c ====================================================================
@node Copying, Systems, Top, Top
@unnumbered Copying
@quotation
This program is distributed under the terms of the Microsoft Public
License.
@end quotation



@c ====================================================================
@c Systems
@c ====================================================================
@node Systems, Files, Copying, Top
@chapter Systems
The main system appears first, followed by any subsystem dependency.

@menu
* The data-frame system::
@end menu


@c ---------------------
@c The data-frame system
@c ---------------------
@node The data-frame system, , Systems, Systems
@section @t{data-frame}
@anchor{❨1❩}@c
@systemindex{data-frame}@c
A data manipulation library for statistical computing
@table @strong
@item Long Name
Data frames for Common Lisp
@item Author
Steve Nunez <@email{steve@atchar{}symbolics.tech}>
@item Home Page
@uref{https://lisp-stat.dev/docs/manuals/data-frame}
@item Source Control
@t{(GIT https://github.com/Lisp-Stat/data-frame.git)}
@item Bug Tracker
@uref{https://github.com/Lisp-Stat/data-frame/issues}
@item License
MS-PL
@item Long Description
A data frame is a common way of storing data for statistical analysis.  Under the hood@comma{} a data frame is a vector of equal-length vectors.  Each element of the vector can be thought of as a column and the length of each element of the vector is the number of rows.  As a result@comma{} data frames can store different classes of objects in each column (i.e. numeric@comma{} character@comma{} factor).  In essence@comma{} the easiest way to think of a data frame is as an Excel worksheet that contains columns of different types of data but are all of equal length rows.

From a design perspective@comma{} Lisp-Stat's data frame is conceptually most similar to the 'tibble' from the tidyverse@comma{} but using Common Lisp idioms@comma{} style and syntax.
@item Version
1.0.0
@item Dependencies
@itemize @bullet
@item
@t{alexandria}@: (system).
@item
@t{alexandria+}@: (system).
@item
@t{anaphora}@: (system).
@item
@t{array-operations}@: (system).
@item
@t{num-utils}@: (system).
@item
@t{select}@: (system).
@item
@t{let-plus}@: (system).
@item
@t{duologue}@: (system).
@end itemize
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Child Components
@itemize @bullet
@item
@ref{❨3❩, , @t{pkgdcl.lisp}}@: (file).
@item
@ref{❨4❩, , @t{utils.lisp}}@: (file).
@item
@ref{❨5❩, , @t{conditions.lisp}}@: (file).
@item
@ref{❨6❩, , @t{data-frame.lisp}}@: (file).
@item
@ref{❨7❩, , @t{pprint.lisp}}@: (file).
@item
@ref{❨8❩, , @t{formatted-output.lisp}}@: (file).
@item
@ref{❨9❩, , @t{summary.lisp}}@: (file).
@item
@ref{❨10❩, , @t{defdf.lisp}}@: (file).
@item
@ref{❨11❩, , @t{properties.lisp}}@: (file).
@item
@ref{❨12❩, , @t{missing.lisp}}@: (file).
@item
@ref{❨13❩, , @t{filter.lisp}}@: (file).
@end itemize
@end table



@c ====================================================================
@c Files
@c ====================================================================
@node Files, Packages, Systems, Top
@chapter Files
Files are sorted by type and then listed depth-first from the systems
components trees.

@menu
* Lisp files::
@end menu


@c ----------
@c Lisp files
@c ----------
@node Lisp files, , Files, Files
@section Lisp
@menu
* The data-frame/data-frame․asd file::
* The data-frame/pkgdcl․lisp file::
* The data-frame/utils․lisp file::
* The data-frame/conditions․lisp file::
* The data-frame/data-frame․lisp file::
* The data-frame/pprint․lisp file::
* The data-frame/formatted-output․lisp file::
* The data-frame/summary․lisp file::
* The data-frame/defdf․lisp file::
* The data-frame/properties․lisp file::
* The data-frame/missing․lisp file::
* The data-frame/filter․lisp file::
@end menu

@node The data-frame/data-frame․asd file, The data-frame/pkgdcl․lisp file, Lisp files, Lisp files
@subsection @t{data-frame/data-frame.asd}
@anchor{❨2❩}@c
@fileindex{data-frame.asd}@c
@table @strong
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item ASDF Systems
@ref{❨1❩, , @t{data-frame}}.
@end table

@node The data-frame/pkgdcl․lisp file, The data-frame/utils․lisp file, The data-frame/data-frame․asd file, Lisp files
@subsection @t{data-frame/pkgdcl.lisp}
@anchor{❨3❩}@c
@fileindex{pkgdcl.lisp}@c
@table @strong
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Packages
@ref{❨14❩, , @t{data-frame}}.
@end table

@node The data-frame/utils․lisp file, The data-frame/conditions․lisp file, The data-frame/pkgdcl․lisp file, Lisp files
@subsection @t{data-frame/utils.lisp}
@anchor{❨4❩}@c
@fileindex{utils.lisp}@c
@table @strong
@item Dependency
@ref{❨3❩, , @t{pkgdcl.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨41❩, , @t{column-type}}@: (function).
@item
@ref{❨50❩, , @t{delete-nth}}@: (function).
@item
@ref{❨118❩, , @t{delete-nth*}}@: (macro).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨166❩, , @t{get-type}}@: (function).
@item
@ref{❨157❩, , @t{types-in-column}}@: (function).
@end itemize
@end table

@node The data-frame/conditions․lisp file, The data-frame/data-frame․lisp file, The data-frame/utils․lisp file, Lisp files
@subsection @t{data-frame/conditions.lisp}
@anchor{❨5❩}@c
@fileindex{conditions.lisp}@c
@table @strong
@item Dependency
@ref{❨4❩, , @t{utils.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨46❩, , @t{data-frame}}@: (reader method).
@item
@ref{❨112❩, , @t{duplicate-key}}@: (condition).
@item
@ref{❨54❩, , @t{key-not-found}}@: (condition).
@item
@ref{❨35❩, , @t{large-data}}@: (condition).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨160❩, , @t{data-frame-exists}}@: (condition).
@item
@ref{❨171❩, , @t{data-size}}@: (reader method).
@item
@ref{❨140❩, , @t{df-exists-p}}@: (function).
@item
@ref{❨178❩, , @t{invalid-df-name}}@: (function).
@item
@ref{❨131❩, , @t{missing-data}}@: (condition).
@end itemize
@end table

@node The data-frame/data-frame․lisp file, The data-frame/pprint․lisp file, The data-frame/conditions․lisp file, Lisp files
@subsection @t{data-frame/data-frame.lisp}
@anchor{❨6❩}@c
@fileindex{data-frame.lisp}@c
@table @strong
@item Dependency
@ref{❨5❩, , @t{conditions.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨40❩, , @t{*large-data*}}@: (special variable).
@item
@ref{❨34❩, , @t{add-column!}}@: (function).
@item
@ref{❨17❩, , @t{add-columns}}@: (function).
@item
@ref{❨117❩, , @t{add-columns!}}@: (function).
@item
@ref{❨67❩, , @t{alist-df}}@: (function).
@item
@ref{❨62❩, , @t{alist-dv}}@: (function).
@item
@ref{❨278❩, , @t{as-alist}}@: (method).
@item
@ref{❨258❩, , @t{as-array}}@: (method).
@item
@ref{❨263❩, , @t{as-array}}@: (method).
@item
@ref{❨285❩, , @t{axis-dimension}}@: (method).
@item
@ref{❨284❩, , @t{canonical-representation}}@: (method).
@item
@ref{❨48❩, , @t{column}}@: (function).
@item
@ref{❨49❩, , @t{(setf column)}}@: (function).
@item
@ref{❨37❩, , @t{column-names}}@: (function).
@item
@ref{❨71❩, , @t{columns}}@: (function).
@item
@ref{❨66❩, , @t{copy}}@: (function).
@item
@ref{❨53❩, , @t{count-rows}}@: (function).
@item
@ref{❨47❩, , @t{data-frame}}@: (class).
@item
@ref{❨116❩, , @t{data-type}}@: (type).
@item
@ref{❨43❩, , @t{data-vector}}@: (class).
@item
@ref{❨260❩, , @t{describe-object}}@: (method).
@item
@ref{❨25❩, , @t{df}}@: (function).
@item
@ref{❨60❩, , @t{df-remove-duplicates}}@: (function).
@item
@ref{❨259❩, , @t{dims}}@: (method).
@item
@ref{❨264❩, , @t{dims}}@: (method).
@item
@ref{❨86❩, , @t{do-rows}}@: (function).
@item
@ref{❨28❩, , @t{dv}}@: (function).
@item
@ref{❨279❩, , @t{element-type}}@: (method).
@item
@ref{❨267❩, , @t{initialize-instance}}@: (method).
@item
@ref{❨70❩, , @t{keys}}@: (function).
@item
@ref{❨84❩, , @t{make-df}}@: (function).
@item
@ref{❨89❩, , @t{make-dv}}@: (function).
@item
@ref{❨85❩, , @t{map-columns}}@: (function).
@item
@ref{❨19❩, , @t{map-df}}@: (function).
@item
@ref{❨74❩, , @t{map-rows}}@: (function).
@item
@ref{❨15❩, , @t{mask-rows}}@: (function).
@item
@ref{❨21❩, , @t{matrix-df}}@: (function).
@item
@ref{❨30❩, , @t{name}}@: (reader method).
@item
@ref{❨32❩, , @t{(setf name)}}@: (writer method).
@item
@ref{❨265❩, , @t{ncol}}@: (method).
@item
@ref{❨266❩, , @t{nrow}}@: (method).
@item
@ref{❨100❩, , @t{plist-df}}@: (function).
@item
@ref{❨99❩, , @t{plist-dv}}@: (function).
@item
@ref{❨256❩, , @t{print-object}}@: (method).
@item
@ref{❨261❩, , @t{print-object}}@: (method).
@item
@ref{❨282❩, , @t{print-object}}@: (method).
@item
@ref{❨61❩, , @t{remove-column!}}@: (function).
@item
@ref{❨91❩, , @t{remove-columns}}@: (function).
@item
@ref{❨94❩, , @t{rename-column!}}@: (method).
@item
@ref{❨22❩, , @t{replace-column}}@: (function).
@item
@ref{❨24❩, , @t{replace-column!}}@: (function).
@item
@ref{❨96❩, , @t{rows}}@: (function).
@item
@ref{❨257❩, , @t{select}}@: (method).
@item
@ref{❨262❩, , @t{select}}@: (method).
@item
@ref{❨283❩, , @t{select}}@: (method).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨194❩, , @t{add-key!}}@: (function).
@item
@ref{❨214❩, , @t{add-keys}}@: (function).
@item
@ref{❨208❩, , @t{alist-data}}@: (function).
@item
@ref{❨135❩, , @t{check-column-compatibility}}@: (generic function).
@item
@ref{❨163❩, , @t{copy-ordered-keys}}@: (function).
@item
@ref{❨127❩, , @t{data}}@: (class).
@item
@ref{❨205❩, , @t{define-data-subclass}}@: (macro).
@item
@ref{❨122❩, , @t{df-env-p}}@: (function).
@item
@ref{❨217❩, , @t{ensure-arguments-alist}}@: (function).
@item
@ref{❨215❩, , @t{key-index}}@: (function).
@item
@ref{❨144❩, , @t{keys-count}}@: (function).
@item
@ref{❨124❩, , @t{keys-vector}}@: (function).
@item
@ref{❨138❩, , @t{make-data}}@: (function).
@item
@ref{❨229❩, , @t{make-ordered-keys}}@: (function).
@item
@ref{❨226❩, , @t{ordered-keys}}@: (function).
@item
@ref{❨227❩, , @t{ordered-keys}}@: (structure).
@item
@ref{❨186❩, , @t{ordered-keys-p}}@: (function).
@item
@ref{❨169❩, , @t{ordered-keys-table}}@: (reader).
@item
@ref{❨158❩, , @t{plist-data}}@: (function).
@item
@ref{❨141❩, , @t{remove-columns!}}@: (function).
@item
@ref{❨203❩, , @t{remove-key!}}@: (function).
@end itemize
@end table

@node The data-frame/pprint․lisp file, The data-frame/formatted-output․lisp file, The data-frame/data-frame․lisp file, Lisp files
@subsection @t{data-frame/pprint.lisp}
@anchor{❨7❩}@c
@fileindex{pprint.lisp}@c
@table @strong
@item Dependency
@ref{❨6❩, , @t{data-frame.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨73❩, , @t{head}}@: (method).
@item
@ref{❨51❩, , @t{print-array}}@: (function).
@item
@ref{❨20❩, , @t{print-data}}@: (function).
@item
@ref{❨97❩, , @t{short-string}}@: (function).
@item
@ref{❨115❩, , @t{tail}}@: (method).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨201❩, , @t{*max-digits*}}@: (special variable).
@item
@ref{❨174❩, , @t{*row-numbers-p*}}@: (special variable).
@item
@ref{❨176❩, , @t{2d-array-to-list}}@: (function).
@item
@ref{❨154❩, , @t{column-type-format}}@: (function).
@item
@ref{❨213❩, , @t{default-column-formats}}@: (method).
@item
@ref{❨181❩, , @t{max-decimal}}@: (function).
@item
@ref{❨199❩, , @t{max-width}}@: (function).
@item
@ref{❨183❩, , @t{printer-status}}@: (function).
@item
@ref{❨206❩, , @t{reverse-df}}@: (function).
@end itemize
@end table

@node The data-frame/formatted-output․lisp file, The data-frame/summary․lisp file, The data-frame/pprint․lisp file, Lisp files
@subsection @t{data-frame/formatted-output.lisp}
@anchor{❨8❩}@c
@fileindex{formatted-output.lisp}@c
@table @strong
@item Dependency
@ref{❨7❩, , @t{pprint.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨23❩, , @t{df-print}}@: (function).
@item
@ref{❨92❩, , @t{print-markdown}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨152❩, , @t{aesthetic-string}}@: (function).
@item
@ref{❨185❩, , @t{print-table}}@: (function).
@item
@ref{❨177❩, , @t{weave}}@: (function).
@end itemize
@end table

@node The data-frame/summary․lisp file, The data-frame/defdf․lisp file, The data-frame/formatted-output․lisp file, Lisp files
@subsection @t{data-frame/summary.lisp}
@anchor{❨9❩}@c
@fileindex{summary.lisp}@c
@table @strong
@item Dependency
@ref{❨8❩, , @t{formatted-output.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨65❩, , @t{*distinct-maximum*}}@: (special variable).
@item
@ref{❨52❩, , @t{*distinct-threshold*}}@: (special variable).
@item
@ref{❨16❩, , @t{*quantile-threshold*}}@: (special variable).
@item
@ref{❨75❩, , @t{*summary-minimum-length*}}@: (special variable).
@item
@ref{❨68❩, , @t{bit-variable-summary}}@: (structure).
@item
@ref{❨63❩, , @t{factor-variable-summary}}@: (structure).
@item
@ref{❨57❩, , @t{generic-variable-summary}}@: (structure).
@item
@ref{❨120❩, , @t{get-summaries}}@: (function).
@item
@ref{❨269❩, , @t{print-object}}@: (method).
@item
@ref{❨270❩, , @t{print-object}}@: (method).
@item
@ref{❨271❩, , @t{print-object}}@: (method).
@item
@ref{❨272❩, , @t{print-object}}@: (method).
@item
@ref{❨76❩, , @t{real-variable-summary}}@: (structure).
@item
@ref{❨42❩, , @t{summarize-column}}@: (function).
@item
@ref{❨83❩, , @t{summary}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨173❩, , @t{bit-variable-summary-count}}@: (reader).
@item
@ref{❨165❩, , @t{bit-variable-summary-desc}}@: (function).
@item
@ref{❨223❩, , @t{bit-variable-summary-length}}@: (function).
@item
@ref{❨134❩, , @t{bit-variable-summary-missing}}@: (function).
@item
@ref{❨162❩, , @t{bit-variable-summary-name}}@: (function).
@item
@ref{❨225❩, , @t{bit-variable-summary-p}}@: (function).
@item
@ref{❨190❩, , @t{column-length}}@: (generic function).
@item
@ref{❨153❩, , @t{copy-bit-variable-summary}}@: (function).
@item
@ref{❨230❩, , @t{copy-factor-variable-summary}}@: (function).
@item
@ref{❨209❩, , @t{copy-generic-variable-summary}}@: (function).
@item
@ref{❨156❩, , @t{copy-real-variable-summary}}@: (function).
@item
@ref{❨221❩, , @t{copy-variable-summary%}}@: (function).
@item
@ref{❨233❩, , @t{distinct}}@: (function).
@item
@ref{❨196❩, , @t{ensure-not-ratio}}@: (function).
@item
@ref{❨143❩, , @t{factor-variable-summary-desc}}@: (function).
@item
@ref{❨172❩, , @t{factor-variable-summary-element-count-alist}}@: (reader).
@item
@ref{❨195❩, , @t{factor-variable-summary-length}}@: (function).
@item
@ref{❨145❩, , @t{factor-variable-summary-missing}}@: (function).
@item
@ref{❨219❩, , @t{factor-variable-summary-name}}@: (function).
@item
@ref{❨197❩, , @t{factor-variable-summary-p}}@: (function).
@item
@ref{❨224❩, , @t{generic-variable-summary-desc}}@: (function).
@item
@ref{❨193❩, , @t{generic-variable-summary-element-count-alist}}@: (reader).
@item
@ref{❨211❩, , @t{generic-variable-summary-length}}@: (function).
@item
@ref{❨234❩, , @t{generic-variable-summary-missing}}@: (function).
@item
@ref{❨139❩, , @t{generic-variable-summary-name}}@: (function).
@item
@ref{❨220❩, , @t{generic-variable-summary-p}}@: (function).
@item
@ref{❨202❩, , @t{generic-variable-summary-quantiles}}@: (reader).
@item
@ref{❨167❩, , @t{make-bit-variable-summary}}@: (function).
@item
@ref{❨204❩, , @t{make-factor-variable-summary}}@: (function).
@item
@ref{❨207❩, , @t{make-generic-variable-summary}}@: (function).
@item
@ref{❨159❩, , @t{make-real-variable-summary}}@: (function).
@item
@ref{❨168❩, , @t{make-variable-summary%}}@: (function).
@item
@ref{❨180❩, , @t{monotonicp}}@: (function).
@item
@ref{❨235❩, , @t{print-count-and-percentage}}@: (function).
@item
@ref{❨126❩, , @t{real-variable-summary-desc}}@: (function).
@item
@ref{❨184❩, , @t{real-variable-summary-length}}@: (function).
@item
@ref{❨151❩, , @t{real-variable-summary-max}}@: (reader).
@item
@ref{❨188❩, , @t{real-variable-summary-mean}}@: (reader).
@item
@ref{❨192❩, , @t{real-variable-summary-min}}@: (reader).
@item
@ref{❨125❩, , @t{real-variable-summary-missing}}@: (function).
@item
@ref{❨210❩, , @t{real-variable-summary-name}}@: (function).
@item
@ref{❨231❩, , @t{real-variable-summary-p}}@: (function).
@item
@ref{❨218❩, , @t{real-variable-summary-q25}}@: (reader).
@item
@ref{❨182❩, , @t{real-variable-summary-q50}}@: (reader).
@item
@ref{❨198❩, , @t{real-variable-summary-q75}}@: (reader).
@item
@ref{❨121❩, , @t{summarize-factor-variable}}@: (function).
@item
@ref{❨142❩, , @t{summarize-generic-variable}}@: (function).
@item
@ref{❨222❩, , @t{summarize-real-variable}}@: (function).
@item
@ref{❨146❩, , @t{variable-summary%}}@: (structure).
@item
@ref{❨187❩, , @t{variable-summary%-desc}}@: (reader).
@item
@ref{❨189❩, , @t{variable-summary%-length}}@: (reader).
@item
@ref{❨232❩, , @t{variable-summary%-missing}}@: (reader).
@item
@ref{❨175❩, , @t{variable-summary%-name}}@: (reader).
@item
@ref{❨200❩, , @t{variable-summary%-p}}@: (function).
@end itemize
@end table

@node The data-frame/defdf․lisp file, The data-frame/properties․lisp file, The data-frame/summary․lisp file, Lisp files
@subsection @t{data-frame/defdf.lisp}
@anchor{❨10❩}@c
@fileindex{defdf.lisp}@c
@table @strong
@item Dependency
@ref{❨9❩, , @t{summary.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨88❩, , @t{*ask-on-redefine*}}@: (special variable).
@item
@ref{❨26❩, , @t{defdf}}@: (macro).
@item
@ref{❨18❩, , @t{defdf-env}}@: (function).
@item
@ref{❨44❩, , @t{show-data-frames}}@: (function).
@item
@ref{❨33❩, , @t{undef}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨123❩, , @t{*data-frames*}}@: (special variable).
@item
@ref{❨164❩, , @t{show-symbols}}@: (function).
@end itemize
@end table

@node The data-frame/properties․lisp file, The data-frame/missing․lisp file, The data-frame/defdf․lisp file, Lisp files
@subsection @t{data-frame/properties.lisp}
@anchor{❨11❩}@c
@fileindex{properties.lisp}@c
@table @strong
@item Dependency
@ref{❨10❩, , @t{defdf.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨98❩, , @t{get-property}}@: (function).
@item
@ref{❨27❩, , @t{heuristicate-types}}@: (function).
@item
@ref{❨119❩, , @t{set-properties}}@: (function).
@item
@ref{❨90❩, , @t{set-property}}@: (function).
@end itemize
@item Internals
@ref{❨216❩, , @t{show-properties}}@: (function).
@end table

@node The data-frame/missing․lisp file, The data-frame/filter․lisp file, The data-frame/properties․lisp file, Lisp files
@subsection @t{data-frame/missing.lisp}
@anchor{❨12❩}@c
@fileindex{missing.lisp}@c
@table @strong
@item Dependency
@ref{❨11❩, , @t{properties.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨110❩, , @t{drop-missing}}@: (method).
@item
@ref{❨111❩, , @t{drop-missing}}@: (method).
@item
@ref{❨95❩, , @t{ignore-missing}}@: (function).
@item
@ref{❨101❩, , @t{missingp}}@: (generic function).
@item
@ref{❨39❩, , @t{replace-missing}}@: (method).
@end itemize
@item Internals
@ref{❨179❩, , @t{drop-na}}@: (function).
@end table

@node The data-frame/filter․lisp file, , The data-frame/missing․lisp file, Lisp files
@subsection @t{data-frame/filter.lisp}
@anchor{❨13❩}@c
@fileindex{filter.lisp}@c
@table @strong
@item Dependency
@ref{❨12❩, , @t{missing.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{data-frame.asd}}.
@item Parent Component
@ref{❨1❩, , @t{data-frame}}@: (system).
@item Public Interface
@ref{❨87❩, , @t{filter-rows}}@: (function).
@item Internals
@ref{❨155❩, , @t{key-list}}@: (function).
@end table



@c ====================================================================
@c Packages
@c ====================================================================
@node Packages, Definitions, Files, Top
@chapter Packages
Packages are listed by definition order.

@menu
* The data-frame package::
@end menu


@c ----------------------
@c The data-frame package
@c ----------------------
@node The data-frame package, , Packages, Packages
@section @t{data-frame}
@anchor{❨14❩}@c
@packageindex{data-frame}@c
@table @strong
@item Source
@ref{❨3❩, , @t{pkgdcl.lisp}}.
@item Nickname
@t{df}
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{alexandria+}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@t{select}.
@item
@t{select-dev}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{dfio}.
@item
@t{lisp-stat}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨88❩, , @t{*ask-on-redefine*}}@: (special variable).
@item
@ref{❨65❩, , @t{*distinct-maximum*}}@: (special variable).
@item
@ref{❨52❩, , @t{*distinct-threshold*}}@: (special variable).
@item
@ref{❨40❩, , @t{*large-data*}}@: (special variable).
@item
@ref{❨16❩, , @t{*quantile-threshold*}}@: (special variable).
@item
@ref{❨75❩, , @t{*summary-minimum-length*}}@: (special variable).
@item
@ref{❨34❩, , @t{add-column!}}@: (function).
@item
@ref{❨17❩, , @t{add-columns}}@: (function).
@item
@ref{❨117❩, , @t{add-columns!}}@: (function).
@item
@ref{❨67❩, , @t{alist-df}}@: (function).
@item
@ref{❨62❩, , @t{alist-dv}}@: (function).
@item
@ref{❨68❩, , @t{bit-variable-summary}}@: (structure).
@item
@ref{❨48❩, , @t{column}}@: (function).
@item
@ref{❨49❩, , @t{(setf column)}}@: (function).
@item
@ref{❨37❩, , @t{column-names}}@: (function).
@item
@ref{❨41❩, , @t{column-type}}@: (function).
@item
@ref{❨71❩, , @t{columns}}@: (function).
@item
@ref{❨66❩, , @t{copy}}@: (function).
@item
@ref{❨53❩, , @t{count-rows}}@: (function).
@item
@ref{❨45❩, , @t{data-frame}}@: (generic reader).
@item
@ref{❨47❩, , @t{data-frame}}@: (class).
@item
@ref{❨116❩, , @t{data-type}}@: (type).
@item
@ref{❨43❩, , @t{data-vector}}@: (class).
@item
@ref{❨26❩, , @t{defdf}}@: (macro).
@item
@ref{❨18❩, , @t{defdf-env}}@: (function).
@item
@ref{❨50❩, , @t{delete-nth}}@: (function).
@item
@ref{❨118❩, , @t{delete-nth*}}@: (macro).
@item
@ref{❨25❩, , @t{df}}@: (function).
@item
@ref{❨23❩, , @t{df-print}}@: (function).
@item
@ref{❨60❩, , @t{df-remove-duplicates}}@: (function).
@item
@ref{❨86❩, , @t{do-rows}}@: (function).
@item
@ref{❨109❩, , @t{drop-missing}}@: (generic function).
@item
@ref{❨112❩, , @t{duplicate-key}}@: (condition).
@item
@ref{❨28❩, , @t{dv}}@: (function).
@item
@ref{❨63❩, , @t{factor-variable-summary}}@: (structure).
@item
@ref{❨87❩, , @t{filter-rows}}@: (function).
@item
@ref{❨57❩, , @t{generic-variable-summary}}@: (structure).
@item
@ref{❨98❩, , @t{get-property}}@: (function).
@item
@ref{❨120❩, , @t{get-summaries}}@: (function).
@item
@ref{❨72❩, , @t{head}}@: (generic function).
@item
@ref{❨27❩, , @t{heuristicate-types}}@: (function).
@item
@ref{❨95❩, , @t{ignore-missing}}@: (function).
@item
@ref{❨54❩, , @t{key-not-found}}@: (condition).
@item
@ref{❨70❩, , @t{keys}}@: (function).
@item
@ref{❨35❩, , @t{large-data}}@: (condition).
@item
@ref{❨84❩, , @t{make-df}}@: (function).
@item
@ref{❨89❩, , @t{make-dv}}@: (function).
@item
@ref{❨85❩, , @t{map-columns}}@: (function).
@item
@ref{❨19❩, , @t{map-df}}@: (function).
@item
@ref{❨74❩, , @t{map-rows}}@: (function).
@item
@ref{❨15❩, , @t{mask-rows}}@: (function).
@item
@ref{❨21❩, , @t{matrix-df}}@: (function).
@item
@ref{❨101❩, , @t{missingp}}@: (generic function).
@item
@ref{❨29❩, , @t{name}}@: (generic reader).
@item
@ref{❨31❩, , @t{(setf name)}}@: (generic writer).
@item
@ref{❨100❩, , @t{plist-df}}@: (function).
@item
@ref{❨99❩, , @t{plist-dv}}@: (function).
@item
@ref{❨51❩, , @t{print-array}}@: (function).
@item
@ref{❨20❩, , @t{print-data}}@: (function).
@item
@ref{❨92❩, , @t{print-markdown}}@: (function).
@item
@ref{❨76❩, , @t{real-variable-summary}}@: (structure).
@item
@ref{❨61❩, , @t{remove-column!}}@: (function).
@item
@ref{❨91❩, , @t{remove-columns}}@: (function).
@item
@ref{❨93❩, , @t{rename-column!}}@: (generic function).
@item
@ref{❨22❩, , @t{replace-column}}@: (function).
@item
@ref{❨24❩, , @t{replace-column!}}@: (function).
@item
@ref{❨38❩, , @t{replace-missing}}@: (generic function).
@item
@ref{❨96❩, , @t{rows}}@: (function).
@item
@ref{❨119❩, , @t{set-properties}}@: (function).
@item
@ref{❨90❩, , @t{set-property}}@: (function).
@item
@ref{❨97❩, , @t{short-string}}@: (function).
@item
@ref{❨44❩, , @t{show-data-frames}}@: (function).
@item
@ref{❨42❩, , @t{summarize-column}}@: (function).
@item
@ref{❨83❩, , @t{summary}}@: (function).
@item
@ref{❨114❩, , @t{tail}}@: (generic function).
@item
@ref{❨33❩, , @t{undef}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨123❩, , @t{*data-frames*}}@: (special variable).
@item
@ref{❨201❩, , @t{*max-digits*}}@: (special variable).
@item
@ref{❨174❩, , @t{*row-numbers-p*}}@: (special variable).
@item
@ref{❨176❩, , @t{2d-array-to-list}}@: (function).
@item
@ref{❨194❩, , @t{add-key!}}@: (function).
@item
@ref{❨214❩, , @t{add-keys}}@: (function).
@item
@ref{❨152❩, , @t{aesthetic-string}}@: (function).
@item
@ref{❨208❩, , @t{alist-data}}@: (function).
@item
@ref{❨173❩, , @t{bit-variable-summary-count}}@: (reader).
@item
@ref{❨165❩, , @t{bit-variable-summary-desc}}@: (function).
@item
@ref{❨223❩, , @t{bit-variable-summary-length}}@: (function).
@item
@ref{❨134❩, , @t{bit-variable-summary-missing}}@: (function).
@item
@ref{❨162❩, , @t{bit-variable-summary-name}}@: (function).
@item
@ref{❨225❩, , @t{bit-variable-summary-p}}@: (function).
@item
@ref{❨135❩, , @t{check-column-compatibility}}@: (generic function).
@item
@ref{❨190❩, , @t{column-length}}@: (generic function).
@item
@ref{❨154❩, , @t{column-type-format}}@: (function).
@item
@ref{❨153❩, , @t{copy-bit-variable-summary}}@: (function).
@item
@ref{❨230❩, , @t{copy-factor-variable-summary}}@: (function).
@item
@ref{❨209❩, , @t{copy-generic-variable-summary}}@: (function).
@item
@ref{❨163❩, , @t{copy-ordered-keys}}@: (function).
@item
@ref{❨156❩, , @t{copy-real-variable-summary}}@: (function).
@item
@ref{❨221❩, , @t{copy-variable-summary%}}@: (function).
@item
@ref{❨127❩, , @t{data}}@: (class).
@item
@ref{❨160❩, , @t{data-frame-exists}}@: (condition).
@item
@ref{❨170❩, , @t{data-size}}@: (generic reader).
@item
@ref{❨212❩, , @t{default-column-formats}}@: (generic function).
@item
@ref{❨205❩, , @t{define-data-subclass}}@: (macro).
@item
@ref{❨122❩, , @t{df-env-p}}@: (function).
@item
@ref{❨140❩, , @t{df-exists-p}}@: (function).
@item
@ref{❨233❩, , @t{distinct}}@: (function).
@item
@ref{❨179❩, , @t{drop-na}}@: (function).
@item
@ref{❨217❩, , @t{ensure-arguments-alist}}@: (function).
@item
@ref{❨196❩, , @t{ensure-not-ratio}}@: (function).
@item
@ref{❨143❩, , @t{factor-variable-summary-desc}}@: (function).
@item
@ref{❨172❩, , @t{factor-variable-summary-element-count-alist}}@: (reader).
@item
@ref{❨195❩, , @t{factor-variable-summary-length}}@: (function).
@item
@ref{❨145❩, , @t{factor-variable-summary-missing}}@: (function).
@item
@ref{❨219❩, , @t{factor-variable-summary-name}}@: (function).
@item
@ref{❨197❩, , @t{factor-variable-summary-p}}@: (function).
@item
@ref{❨224❩, , @t{generic-variable-summary-desc}}@: (function).
@item
@ref{❨193❩, , @t{generic-variable-summary-element-count-alist}}@: (reader).
@item
@ref{❨211❩, , @t{generic-variable-summary-length}}@: (function).
@item
@ref{❨234❩, , @t{generic-variable-summary-missing}}@: (function).
@item
@ref{❨139❩, , @t{generic-variable-summary-name}}@: (function).
@item
@ref{❨220❩, , @t{generic-variable-summary-p}}@: (function).
@item
@ref{❨202❩, , @t{generic-variable-summary-quantiles}}@: (reader).
@item
@ref{❨166❩, , @t{get-type}}@: (function).
@item
@ref{❨178❩, , @t{invalid-df-name}}@: (function).
@item
@ref{❨215❩, , @t{key-index}}@: (function).
@item
@ref{❨155❩, , @t{key-list}}@: (function).
@item
@ref{❨144❩, , @t{keys-count}}@: (function).
@item
@ref{❨124❩, , @t{keys-vector}}@: (function).
@item
@ref{❨167❩, , @t{make-bit-variable-summary}}@: (function).
@item
@ref{❨138❩, , @t{make-data}}@: (function).
@item
@ref{❨204❩, , @t{make-factor-variable-summary}}@: (function).
@item
@ref{❨207❩, , @t{make-generic-variable-summary}}@: (function).
@item
@ref{❨229❩, , @t{make-ordered-keys}}@: (function).
@item
@ref{❨159❩, , @t{make-real-variable-summary}}@: (function).
@item
@ref{❨168❩, , @t{make-variable-summary%}}@: (function).
@item
@ref{❨181❩, , @t{max-decimal}}@: (function).
@item
@ref{❨199❩, , @t{max-width}}@: (function).
@item
@ref{❨131❩, , @t{missing-data}}@: (condition).
@item
@ref{❨180❩, , @t{monotonicp}}@: (function).
@item
@ref{❨226❩, , @t{ordered-keys}}@: (function).
@item
@ref{❨227❩, , @t{ordered-keys}}@: (structure).
@item
@ref{❨186❩, , @t{ordered-keys-p}}@: (function).
@item
@ref{❨169❩, , @t{ordered-keys-table}}@: (reader).
@item
@ref{❨158❩, , @t{plist-data}}@: (function).
@item
@ref{❨235❩, , @t{print-count-and-percentage}}@: (function).
@item
@ref{❨185❩, , @t{print-table}}@: (function).
@item
@ref{❨183❩, , @t{printer-status}}@: (function).
@item
@ref{❨126❩, , @t{real-variable-summary-desc}}@: (function).
@item
@ref{❨184❩, , @t{real-variable-summary-length}}@: (function).
@item
@ref{❨151❩, , @t{real-variable-summary-max}}@: (reader).
@item
@ref{❨188❩, , @t{real-variable-summary-mean}}@: (reader).
@item
@ref{❨192❩, , @t{real-variable-summary-min}}@: (reader).
@item
@ref{❨125❩, , @t{real-variable-summary-missing}}@: (function).
@item
@ref{❨210❩, , @t{real-variable-summary-name}}@: (function).
@item
@ref{❨231❩, , @t{real-variable-summary-p}}@: (function).
@item
@ref{❨218❩, , @t{real-variable-summary-q25}}@: (reader).
@item
@ref{❨182❩, , @t{real-variable-summary-q50}}@: (reader).
@item
@ref{❨198❩, , @t{real-variable-summary-q75}}@: (reader).
@item
@ref{❨141❩, , @t{remove-columns!}}@: (function).
@item
@ref{❨203❩, , @t{remove-key!}}@: (function).
@item
@ref{❨206❩, , @t{reverse-df}}@: (function).
@item
@ref{❨216❩, , @t{show-properties}}@: (function).
@item
@ref{❨164❩, , @t{show-symbols}}@: (function).
@item
@ref{❨121❩, , @t{summarize-factor-variable}}@: (function).
@item
@ref{❨142❩, , @t{summarize-generic-variable}}@: (function).
@item
@ref{❨222❩, , @t{summarize-real-variable}}@: (function).
@item
@ref{❨157❩, , @t{types-in-column}}@: (function).
@item
@ref{❨146❩, , @t{variable-summary%}}@: (structure).
@item
@ref{❨187❩, , @t{variable-summary%-desc}}@: (reader).
@item
@ref{❨189❩, , @t{variable-summary%-length}}@: (reader).
@item
@ref{❨232❩, , @t{variable-summary%-missing}}@: (reader).
@item
@ref{❨175❩, , @t{variable-summary%-name}}@: (reader).
@item
@ref{❨200❩, , @t{variable-summary%-p}}@: (function).
@item
@ref{❨177❩, , @t{weave}}@: (function).
@end itemize
@end table



@c ====================================================================
@c Definitions
@c ====================================================================
@node Definitions, Indexes, Packages, Top
@chapter Definitions
Definitions are sorted by export status, category, package, and then by
lexicographic order.

@menu
* Public Interface::
* Internals::
@end menu


@c ----------------
@c Public Interface
@c ----------------
@node Public Interface, Internals, Definitions, Definitions
@section Public Interface
@menu
* Public special variables::
* Public macros::
* Public ordinary functions::
* Public generic functions::
* Public standalone methods::
* Public conditions::
* Public structures::
* Public classes::
* Public types::
@end menu

@node Public special variables, Public macros, Public Interface, Public Interface
@subsection Special variables
@defvr {Special Variable} {*ask-on-redefine*}
@anchor{❨88❩}@c
@specialsubindex{*ask-on-redefine*}@c
If non-nil@comma{} the system will ask the user for confirmation before redefining a data frame
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*distinct-maximum*}
@anchor{❨65❩}@c
@specialsubindex{*distinct-maximum*}@c
If a string/factor variable has > *distinct-maximum* values@comma{} exclude it
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*distinct-threshold*}
@anchor{❨52❩}@c
@specialsubindex{*distinct-threshold*}@c
If an integer variable has <= discrete values@comma{} consider it a factor
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*large-data*}
@anchor{❨40❩}@c
@specialsubindex{*large-data*}@c
An indication that the data set is large for a particular use case.@*
This should be bound by a user to the maximum number of data points they consider to be 'normal'. The function can then signal a large-data warning if it is exceeded.

E.g. (let ((df:*large-data* 50000))@*
       (handler-bind ((large-data ...@*
          (some-data-operation ; this will signal if the data is too large@*
            (restart-bind ...
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*quantile-threshold*}
@anchor{❨16❩}@c
@specialsubindex{*quantile-threshold*}@c
If the number of unique reals exceeds this threshold@comma{} they will be summarized with quantiles@comma{} otherwise print frequency table
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*summary-minimum-length*}
@anchor{❨75❩}@c
@specialsubindex{*summary-minimum-length*}@c
Columns are only summarised when longer than this@comma{} otherwise they are returned as is.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end defvr

@node Public macros, Public ordinary functions, Public special variables, Public Interface
@subsection Macros
@deffn {Macro} {defdf} (name data &optional documentation)
@anchor{❨26❩}@c
@macrosubindex{defdf}@c
Define a data-frame and package by the same name.@*
Also defines symbol-macros for variable access@comma{} e.g. mtcars:mpg
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end deffn
@deffn {Macro} {delete-nth*} (place n)
@anchor{❨118❩}@c
@macrosubindex{delete-nth*}@c
Destructively modifies N@comma{} a SEQUENCE by removing the Nth item.
Example:@*
    LS-USER> (defparameter *v* @hashchar{}(a b c d))@*
    *V*@*
    LS-USER> (delete-nth* *v* 1)@*
    @hashchar{}(A C D)@*
    LS-USER> *v*@*
    @hashchar{}(A C D)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨4❩, , @t{utils.lisp}}.
@end table
@end deffn

@node Public ordinary functions, Public generic functions, Public macros, Public Interface
@subsection Ordinary functions
@deffn {Function} {add-column!} (data key column &optional update-env)
@anchor{❨34❩}@c
@functionsubindex{add-column!}@c
Modify DATA (a data-frame or data-vector) by adding COLUMN with KEY.  Return DATA.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {add-columns} (data &rest keys-and-columns)
@anchor{❨17❩}@c
@functionsubindex{add-columns}@c
Return a new data-frame or data-vector with keys and columns added.  Does not modify DATA.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {add-columns!} (data &rest keys-and-columns)
@anchor{❨117❩}@c
@functionsubindex{add-columns!}@c
Modify DATA (a data-frame or data-vector) by adding columns with keys.
If a data-frame environment exists@comma{} add columns to it as well.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {alist-df} (alist)
@anchor{❨67❩}@c
@functionsubindex{alist-df}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {alist-dv} (alist)
@anchor{❨62❩}@c
@functionsubindex{alist-dv}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {column} (data key)
@anchor{❨48❩}@c
@functionsubindex{column}@c
Return column corresponding to key.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf column)} (data key)
@anchor{❨49❩}@c
@functionsubindex{(setf column)}@c
Set column corresponding to key.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {column-names} (df)
@anchor{❨37❩}@c
@functionsubindex{column-names}@c
Return a list of column names in DF@comma{} as strings
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {column-type} (col)
@anchor{❨41❩}@c
@functionsubindex{column-type}@c
Return the most specific type found in COL
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨4❩, , @t{utils.lisp}}.
@end table
@end deffn
@deffn {Function} {columns} (data &optional slice)
@anchor{❨71❩}@c
@functionsubindex{columns}@c
Return the columns of DATA as a vector@comma{} or a selection if given (keys are resolved).
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {copy} (data &key key)
@anchor{❨66❩}@c
@functionsubindex{copy}@c
Copy data frame or vector.  Keys are copied (and thus can be modified)@comma{} columns or elements are copied using KEY@comma{} making the default give a shallow copy.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {count-rows} (data-frame keys predicate)
@anchor{❨53❩}@c
@functionsubindex{count-rows}@c
Count the number of rows for which PREDICATE called on the columns corresponding to KEYS returns non-NIL.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {defdf-env} (data-frame old-keys)
@anchor{❨18❩}@c
@functionsubindex{defdf-env}@c
Create a package with the same name as DATA-FRAME.  Within it@comma{} create a symbol-macro for each column that will return the columns value.
Can also be used to remove and update the environment as the DATA-FRAME changes in destructive operations
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end deffn
@deffn {Function} {delete-nth} (sequence n)
@anchor{❨50❩}@c
@functionsubindex{delete-nth}@c
Return SEQUENCE with the Nth item removed.@*
Note: DELETE-IF makes no guarantee of being destructive@comma{} so you cannot rely on this side-effect.  You must SETF the original sequence to the values returned from this function@comma{} or use the modify-macro DELETE-NTH*
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨4❩, , @t{utils.lisp}}.
@end table
@end deffn
@deffn {Function} {df} (&rest plist-or-alist)
@anchor{❨25❩}@c
@functionsubindex{df}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {df-print} (df)
@anchor{❨23❩}@c
@functionsubindex{df-print}@c
Print DF to *standard-output* in table format
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨8❩, , @t{formatted-output.lisp}}.
@end table
@end deffn
@deffn {Function} {df-remove-duplicates} (data)
@anchor{❨60❩}@c
@functionsubindex{df-remove-duplicates}@c
Return a modified copy of DATA from which any element (row@comma{} if a DATA-FRAME) that matches another element has been removed
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {do-rows} (data-frame keys function)
@anchor{❨86❩}@c
@functionsubindex{do-rows}@c
Traverse rows from first to last@comma{} calling FUNCTION on the columns corresponding to KEYS.  Return no values.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {dv} (&rest plist-or-alist)
@anchor{❨28❩}@c
@functionsubindex{dv}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {filter-rows} (data body)
@anchor{❨87❩}@c
@functionsubindex{filter-rows}@c
Filter DATA by a predicate given in BODY@*

Example@*
   (data :mtcars) ; load a data set@*
   (head mtcars)  ; view first 6 rows@*

;;   MODEL              MPG CYL DISP  HP DRAT    WT  QSEC VS AM GEAR CARB
;; 0 Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
;; 1 Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
;; 2 Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
;; 3 Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
;; 4 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
;; 5 Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1

   (filter-rows mtcars '(< mpg 17))@*
   @hashchar{}<DATA-FRAME (11 observations of 12 variables)>@*

   (head *) ; view first 6 rows of filtered data frame@*

;;   MODEL                MPG CYL  DISP  HP DRAT    WT  QSEC VS AM GEAR CARB
;; 0 Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
;; 1 Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
;; 2 Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
;; 3 Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
;; 4 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
;; 5 Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨13❩, , @t{filter.lisp}}.
@end table
@end deffn
@deffn {Function} {get-property} (variable property)
@anchor{❨98❩}@c
@functionsubindex{get-property}@c
Return the PROPERTY of data VARIABLE
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨11❩, , @t{properties.lisp}}.
@end table
@end deffn
@deffn {Function} {get-summaries} (df)
@anchor{❨120❩}@c
@functionsubindex{get-summaries}@c
Return a list of summaries of the variables in DF
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {heuristicate-types} (df)
@anchor{❨27❩}@c
@functionsubindex{heuristicate-types}@c
Coerce each element of the column vectors to the most specific type in the column@*
Often when reading in a data set@comma{} the types will be inconsistent in a variable.  For example one observation might be 5.1@comma{} and another 5.  Whilst mathmatically equivalent@comma{} we want our variable vectors to have identical types.  The COLUMN-TYPE function returns the most specific numeric type in the column@comma{} then coerces all the vector elements to this type
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨11❩, , @t{properties.lisp}}.
@end table
@end deffn
@deffn {Function} {ignore-missing} (function &key warn-user provide-restart)
@anchor{❨95❩}@c
@functionsubindex{ignore-missing}@c
Wrap FUNCTION in a closure that removes missing values and applys FUNCTION in case any of the arguments are :MISSING@comma{} :NA or NIL to arguments.  Intended for functions accepting vectors.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@end table
@end deffn
@deffn {Function} {keys} (data)
@anchor{❨70❩}@c
@functionsubindex{keys}@c
Return a vector of keys.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {make-df} (keys columns)
@anchor{❨84❩}@c
@functionsubindex{make-df}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {make-dv} (keys columns)
@anchor{❨89❩}@c
@functionsubindex{make-dv}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {map-columns} (data function &optional result-class)
@anchor{❨85❩}@c
@functionsubindex{map-columns}@c
Map columns of DATA-FRAME or DATA-VECTOR using FUNCTION.  The result is a new DATA-FRAME with the same keys.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {map-df} (data-frame keys function result-keys)
@anchor{❨19❩}@c
@functionsubindex{map-df}@c
Map DATA-FRAME to another one by rows.  Function is called on the columns corresponding to KEYS@comma{} and should return a sequence with the same length as RESULT-KEYS@comma{} which give the keys of the resulting data frame.  RESULT-KETS should be either symbols@comma{} or of the format (symbol @ampchar{}optional (element-type t)).
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {map-rows} (data-frame keys function &key element-type)
@anchor{❨74❩}@c
@functionsubindex{map-rows}@c
Map rows using FUNCTION@comma{} on the columns corresponding to KEYS.  Return the result with the given ELEMENT-TYPE.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {mask-rows} (data-frame keys predicate)
@anchor{❨15❩}@c
@functionsubindex{mask-rows}@c
Return a bit-vector containing the result of calling PREDICATE on rows of the columns corresponding to KEYS (0 for NIL@comma{} 1 otherwise).
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {matrix-df} (keys matrix)
@anchor{❨21❩}@c
@functionsubindex{matrix-df}@c
Convert a matrix to a data-frame with the given keys.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {plist-df} (plist)
@anchor{❨100❩}@c
@functionsubindex{plist-df}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {plist-dv} (plist)
@anchor{❨99❩}@c
@functionsubindex{plist-dv}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {print-array} (arr &optional stream row-numbers-p)
@anchor{❨51❩}@c
@functionsubindex{print-array}@c
Print an array to STREAM@comma{} defaulting to *standard-output*@comma{} in a tabular format.  If ROW-NUMBERS-P@comma{} print row numbers.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {print-data} (data-frame &optional stream row-numbers-p max-digits)
@anchor{❨20❩}@c
@functionsubindex{print-data}@c
Print DATA-FRAME to STREAM using the pretty printer
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {print-markdown} (df &key stream row-numbers)
@anchor{❨92❩}@c
@functionsubindex{print-markdown}@c
Print data frame DF@comma{} in markdown format@comma{} to STREAM@*
If ROW-NUMBERS is true@comma{} also print row numbers as the first column
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨8❩, , @t{formatted-output.lisp}}.
@end table
@end deffn
@deffn {Function} {remove-column!} (data key)
@anchor{❨61❩}@c
@functionsubindex{remove-column!}@c
Modify DATA (a data-frame or data-vector) by removing COLUMN with KEY.  Return DATA.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {remove-columns} (data keys)
@anchor{❨91❩}@c
@functionsubindex{remove-columns}@c
Return a new data-frame or data-vector with keys and columns removed.  Does not modify DATA.
ARGS: DATA data frame@*
      KEYS list of keys (variables) to be removed
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {replace-column} (data key function-or-column &key element-type)
@anchor{❨22❩}@c
@functionsubindex{replace-column}@c
Create a new data frame with new column KEY from data-frame DATA by replacing it either with the given column@comma{} or applying the function to the current values (ELEMENT-TYPE is used.)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {replace-column!} (data key function-or-column &key element-type)
@anchor{❨24❩}@c
@functionsubindex{replace-column!}@c
Modify column KEY of data-frame DATA by replacing it either with the given column@comma{} or applying the function to the current values (ELEMENT-TYPE is used.)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {rows} (data)
@anchor{❨96❩}@c
@functionsubindex{rows}@c
Return the rows of DATA as a vector
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {set-properties} (df property prop-values)
@anchor{❨119❩}@c
@functionsubindex{set-properties}@c
Set the PROPERTY of each variable in DF to a value.  The value is specified in the plist PROP-VALUES.
Example:@*
  To give the variables in the mtcars dataset a unit@comma{} use:@*
  (set-properties mtcars :unit '(:mpg  m/g@*
			         :cyl  :NA@*
			         :disp in³@*
			         :hp   hp@*
			         :drat :NA@*
			         :wt   lb@*
			         :qsec s@*
			         :vs   :NA@*
			         :am   :NA@*
			         :gear :NA@*
			         :carb :NA))
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨11❩, , @t{properties.lisp}}.
@end table
@end deffn
@deffn {Function} {set-property} (symbol value property)
@anchor{❨90❩}@c
@functionsubindex{set-property}@c
Set the PROPERTY of SYMBOL to VALUE
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨11❩, , @t{properties.lisp}}.
@end table
@end deffn
@deffn {Function} {short-string} (str)
@anchor{❨97❩}@c
@functionsubindex{short-string}@c
Return up to the first newline@*
This is useful when docstrings are multi-line.  By convention@comma{} the first line is the title.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {show-data-frames} (&key head stream)
@anchor{❨44❩}@c
@functionsubindex{show-data-frames}@c
Print all data frames in the current environment in reverse order of creation@comma{} i.e. most recently created first.
If HEAD is not NIL@comma{} print the first six rows@comma{} similar to the (head) function
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end deffn
@deffn {Function} {summarize-column} (column &optional name)
@anchor{❨42❩}@c
@functionsubindex{summarize-column}@c
Return a summary struct for COLUMN
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {summary} (df &optional stream)
@anchor{❨83❩}@c
@functionsubindex{summary}@c
Print a summary of DF to STREAM@comma{} using heuristics for better formatting
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {undef} (&rest params)
@anchor{❨33❩}@c
@functionsubindex{undef}@c
Remove one or more data frames from the environment@*
PARAMS: a list of DATA-FRAMEs@*

Essentially reverses what DEFDF does.  Returns the data frames that were removed.  Don't use this if you have a data frame bound via DEFPARAMETER.
Examples:@*
    (undef mtcars vlcars)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end deffn

@node Public generic functions, Public standalone methods, Public ordinary functions, Public Interface
@subsection Generic functions
@deffn {Generic Reader} {data-frame} (condition)
@anchor{❨45❩}@c
@genericsubindex{data-frame}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Reader Method} {data-frame} ((condition @ref{❨160❩, , @t{data-frame-exists}}))
@anchor{❨46❩}@c
@methodsubindex{data-frame}@c
@table @strong
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Target Slot
@ref{❨161❩, , @t{data-frame}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {drop-missing} (df &optional predicate)
@anchor{❨109❩}@c
@genericsubindex{drop-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {drop-missing} ((var @t{vector}) &optional predicate)
@anchor{❨110❩}@c
@methodsubindex{drop-missing}@c
Remove all values from VAR that are missing according to PREDICATE.
Returns values:@*
   1. the vector with missing values removed@*
   2. the number of elements removed
@table @strong
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@end table
@end deffn
@deffn {Method} {drop-missing} ((df @ref{❨47❩, , @t{data-frame}}) &optional predicate)
@anchor{❨111❩}@c
@methodsubindex{drop-missing}@c
Remove all rows from DF that are missing values according to PREDICATE
@table @strong
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {head} (df &optional n)
@anchor{❨72❩}@c
@genericsubindex{head}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {head} ((df @ref{❨47❩, , @t{data-frame}}) &optional n)
@anchor{❨73❩}@c
@methodsubindex{head}@c
Return the first N rows of DF; N defaults to 6
@table @strong
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {missingp} (data)
@anchor{❨101❩}@c
@genericsubindex{missingp}@c
Return a vector indicating the position of any missing value indicators.  They currently are :na and :missing
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@item Methods
@deffn {Method} {missingp} (data)
@anchor{❨102❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @t{(eql :na)}))
@anchor{❨103❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @t{(eql :missing)}))
@anchor{❨104❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @t{string}))
@anchor{❨105❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @t{sequence}))
@anchor{❨106❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @t{array}))
@anchor{❨107❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {missingp} ((data @ref{❨47❩, , @t{data-frame}}))
@anchor{❨108❩}@c
@methodsubindex{missingp}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Reader} {name} (object)
@anchor{❨29❩}@c
@genericsubindex{name}@c
@deffnx {Generic Writer} {(setf name)} (object)
@anchor{❨31❩}@c
@genericsubindex{(setf name)}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Reader Method} {name} ((data @ref{❨127❩, , @t{data}}))
@anchor{❨30❩}@c
@methodsubindex{name}@c
@deffnx {Writer Method} {(setf name)} ((data @ref{❨127❩, , @t{data}}))
@anchor{❨32❩}@c
@methodsubindex{(setf name)}@c
The name of the data frame.  MUST be the same as the symbol whose value cell points to this data frame.  This slot essentially allows us to go 'backwards' and get the symbol that names the data frame.
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Target Slot
@ref{❨128❩, , @t{name}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {rename-column!} (data new old)
@anchor{❨93❩}@c
@genericsubindex{rename-column!}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {rename-column!} (data new old)
@anchor{❨94❩}@c
@methodsubindex{rename-column!}@c
Substitute NEW@comma{} a SYMBOL@comma{} for OLD in DF@*

Useful when reading data files that have an empty or generated column name.@*

Example: (rename-column! cars 'name :||) will replace an empty symbol with 'name
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {replace-missing} (df map-alist)
@anchor{❨38❩}@c
@genericsubindex{replace-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {replace-missing} ((df @ref{❨47❩, , @t{data-frame}}) map-alist)
@anchor{❨39❩}@c
@methodsubindex{replace-missing}@c
Replace missing values with the values specified@*
The alist consists of a column name in the CAR and the replacement value in the CDR
Example: (replace-missing mtcarsm '((mpg . foo)))
@table @strong
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {tail} (df &optional n)
@anchor{❨114❩}@c
@genericsubindex{tail}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {tail} ((df @ref{❨47❩, , @t{data-frame}}) &optional n)
@anchor{❨115❩}@c
@methodsubindex{tail}@c
Return the last N rows of DF; N defaults to 6
@table @strong
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@end table
@end deffn

@node Public standalone methods, Public conditions, Public generic functions, Public Interface
@subsection Standalone methods
@deffn {Method} {as-alist} ((data @ref{❨127❩, , @t{data}}))
@anchor{❨278❩}@c
@methodsubindex{as-alist}@c
Key-column pairs as an alist.
@table @strong
@item Package
@t{num-utils.utilities}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {as-array} ((data-vector @ref{❨43❩, , @t{data-vector}}))
@anchor{❨258❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {as-array} ((data-frame @ref{❨47❩, , @t{data-frame}}))
@anchor{❨263❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {axis-dimension} ((axis @ref{❨227❩, , @t{ordered-keys}}))
@anchor{❨285❩}@c
@methodsubindex{axis-dimension}@c
@table @strong
@item Package
@t{select-dev}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {canonical-representation} ((axis @ref{❨227❩, , @t{ordered-keys}}) (slice @t{symbol}))
@anchor{❨284❩}@c
@methodsubindex{canonical-representation}@c
@table @strong
@item Package
@t{select-dev}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {describe-object} ((df @ref{❨47❩, , @t{data-frame}}) stream)
@anchor{❨260❩}@c
@methodsubindex{describe-object}@c
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {dims} ((data-vector @ref{❨43❩, , @t{data-vector}}))
@anchor{❨259❩}@c
@methodsubindex{dims}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {dims} ((data-frame @ref{❨47❩, , @t{data-frame}}))
@anchor{❨264❩}@c
@methodsubindex{dims}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {element-type} ((data @ref{❨127❩, , @t{data}}))
@anchor{❨279❩}@c
@methodsubindex{element-type}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {initialize-instance} :after ((data-frame @ref{❨47❩, , @t{data-frame}}) &rest initargs)
@anchor{❨267❩}@c
@methodsubindex{initialize-instance}@c
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {ncol} ((data-frame @ref{❨47❩, , @t{data-frame}}))
@anchor{❨265❩}@c
@methodsubindex{ncol}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {nrow} ((data-frame @ref{❨47❩, , @t{data-frame}}))
@anchor{❨266❩}@c
@methodsubindex{nrow}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((data-vector @ref{❨43❩, , @t{data-vector}}) stream)
@anchor{❨256❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((df @ref{❨47❩, , @t{data-frame}}) stream)
@anchor{❨261❩}@c
@methodsubindex{print-object}@c
Print DATA-FRAME dimensions and type@*
After defining this method it is permanently associated with data-frame objects
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((object @ref{❨57❩, , @t{generic-variable-summary}}) stream)
@anchor{❨269❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((object @ref{❨63❩, , @t{factor-variable-summary}}) stream)
@anchor{❨270❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((object @ref{❨68❩, , @t{bit-variable-summary}}) stream)
@anchor{❨271❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((object @ref{❨76❩, , @t{real-variable-summary}}) stream)
@anchor{❨272❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((ordered-keys @ref{❨227❩, , @t{ordered-keys}}) stream)
@anchor{❨282❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((data-vector @ref{❨43❩, , @t{data-vector}}) &rest slices)
@anchor{❨257❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((data-frame @ref{❨47❩, , @t{data-frame}}) &rest slices)
@anchor{❨262❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((ordered-keys @ref{❨227❩, , @t{ordered-keys}}) &rest selections)
@anchor{❨283❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn

@node Public conditions, Public structures, Public standalone methods, Public Interface
@subsection Conditions
@deftp {Condition} {duplicate-key}
@anchor{❨112❩}@c
@conditionsubindex{duplicate-key}@c
An operation attempted to use a key that already exists in ORDERED-KEYS
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Direct superclasses
@t{error}.
@item Direct slots
@defvr {Slot} {key}
@anchor{❨113❩}@c
@slotsubindex{key}@c
@table @strong
@item Initargs
@t{:key}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {key-not-found}
@anchor{❨54❩}@c
@conditionsubindex{key-not-found}@c
An operation was attempted on a non-existant key.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Direct superclasses
@t{error}.
@item Direct slots
@defvr {Slot} {key}
@anchor{❨55❩}@c
@slotsubindex{key}@c
@table @strong
@item Initargs
@t{:key}
@end table
@end defvr
@defvr {Slot} {keys}
@anchor{❨56❩}@c
@slotsubindex{keys}@c
@table @strong
@item Initargs
@t{:keys}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {large-data}
@anchor{❨35❩}@c
@conditionsubindex{large-data}@c
A operation was requested on a data set large enough to potentially cause problems.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Direct superclasses
@t{warning}.
@item Direct methods
@ref{❨171❩, , @t{data-size}}.
@item Direct slots
@defvr {Slot} {data-size}
@anchor{❨36❩}@c
@slotsubindex{data-size}@c
@table @strong
@item Initargs
@t{:data-size}
@item Readers
@ref{❨171❩, , @t{data-size}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp

@node Public structures, Public classes, Public conditions, Public Interface
@subsection Structures
@deftp {Structure} {bit-variable-summary}
@anchor{❨68❩}@c
@structuresubindex{bit-variable-summary}@c
Summary of a bit vector.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Direct superclasses
@ref{❨146❩, , @t{variable-summary%}}.
@item Direct methods
@ref{❨271❩, , @t{print-object}}.
@item Direct slots
@defvr {Slot} {count}
@anchor{❨69❩}@c
@slotsubindex{count}@c
@table @strong
@item Package
@t{common-lisp}.
@item Type
@t{alexandria:array-index}
@item Initform
@t{0}
@item Readers
@ref{❨173❩, , @t{bit-variable-summary-count}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {factor-variable-summary}
@anchor{❨63❩}@c
@structuresubindex{factor-variable-summary}@c
Summary for factor variables
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Direct superclasses
@ref{❨146❩, , @t{variable-summary%}}.
@item Direct methods
@ref{❨270❩, , @t{print-object}}.
@item Direct slots
@defvr {Slot} {element-count-alist}
@anchor{❨64❩}@c
@slotsubindex{element-count-alist}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{❨172❩, , @t{factor-variable-summary-element-count-alist}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {generic-variable-summary}
@anchor{❨57❩}@c
@structuresubindex{generic-variable-summary}@c
Summary for generic variables@comma{} i.e. those with mixed types.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Direct superclasses
@ref{❨146❩, , @t{variable-summary%}}.
@item Direct methods
@ref{❨269❩, , @t{print-object}}.
@item Direct slots
@defvr {Slot} {quantiles}
@anchor{❨58❩}@c
@slotsubindex{quantiles}@c
@table @strong
@item Type
@t{(or null data-frame:real-variable-summary)}
@item Readers
@ref{❨202❩, , @t{generic-variable-summary-quantiles}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {element-count-alist}
@anchor{❨59❩}@c
@slotsubindex{element-count-alist}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{❨193❩, , @t{generic-variable-summary-element-count-alist}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {real-variable-summary}
@anchor{❨76❩}@c
@structuresubindex{real-variable-summary}@c
Summary of a real elements (using quantiles).
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Direct superclasses
@ref{❨146❩, , @t{variable-summary%}}.
@item Direct methods
@ref{❨272❩, , @t{print-object}}.
@item Direct slots
@defvr {Slot} {min}
@anchor{❨77❩}@c
@slotsubindex{min}@c
@table @strong
@item Package
@t{common-lisp}.
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨192❩, , @t{real-variable-summary-min}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {q25}
@anchor{❨78❩}@c
@slotsubindex{q25}@c
@table @strong
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨218❩, , @t{real-variable-summary-q25}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {q50}
@anchor{❨79❩}@c
@slotsubindex{q50}@c
@table @strong
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨182❩, , @t{real-variable-summary-q50}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {mean}
@anchor{❨80❩}@c
@slotsubindex{mean}@c
@table @strong
@item Package
@t{alexandria}.
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨188❩, , @t{real-variable-summary-mean}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {q75}
@anchor{❨81❩}@c
@slotsubindex{q75}@c
@table @strong
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨198❩, , @t{real-variable-summary-q75}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {max}
@anchor{❨82❩}@c
@slotsubindex{max}@c
@table @strong
@item Package
@t{common-lisp}.
@item Type
@t{real}
@item Initform
@t{0}
@item Readers
@ref{❨151❩, , @t{real-variable-summary-max}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp

@node Public classes, Public types, Public structures, Public Interface
@subsection Classes
@deftp {Class} {data-frame}
@anchor{❨47❩}@c
@classsubindex{data-frame}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Direct superclasses
@ref{❨127❩, , @t{data}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨263❩, , @t{as-array}}.
@item
@ref{❨136❩, , @t{check-column-compatibility}}.
@item
@ref{❨260❩, , @t{describe-object}}.
@item
@ref{❨264❩, , @t{dims}}.
@item
@ref{❨111❩, , @t{drop-missing}}.
@item
@ref{❨73❩, , @t{head}}.
@item
@ref{❨267❩, , @t{initialize-instance}}.
@item
@ref{❨108❩, , @t{missingp}}.
@item
@ref{❨265❩, , @t{ncol}}.
@item
@ref{❨266❩, , @t{nrow}}.
@item
@ref{❨261❩, , @t{print-object}}.
@item
@ref{❨39❩, , @t{replace-missing}}.
@item
@ref{❨262❩, , @t{select}}.
@item
@ref{❨115❩, , @t{tail}}.
@end itemize
@end table
@end deftp
@deftp {Class} {data-vector}
@anchor{❨43❩}@c
@classsubindex{data-vector}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Direct superclasses
@ref{❨127❩, , @t{data}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨258❩, , @t{as-array}}.
@item
@ref{❨259❩, , @t{dims}}.
@item
@ref{❨256❩, , @t{print-object}}.
@item
@ref{❨257❩, , @t{select}}.
@end itemize
@end table
@end deftp

@node Public types, , Public classes, Public Interface
@subsection Types
@deftp {Type} {data-type} ()
@anchor{❨116❩}@c
@typesubindex{data-type}@c
A statistical type for a data variable.  All data columns must be one of these types if they are to be intepreted properly by Lisp-Stat
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deftp


@c ---------
@c Internals
@c ---------
@node Internals, , Public Interface, Definitions
@section Internals
@menu
* Private special variables::
* Private macros::
* Private ordinary functions::
* Private generic functions::
* Private conditions::
* Private structures::
* Private classes::
@end menu

@node Private special variables, Private macros, Internals, Internals
@subsection Special variables
@defvr {Special Variable} {*data-frames*}
@anchor{❨123❩}@c
@specialsubindex{*data-frames*}@c
Global list of all data frames
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*max-digits*}
@anchor{❨201❩}@c
@specialsubindex{*max-digits*}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*row-numbers-p*}
@anchor{❨174❩}@c
@specialsubindex{*row-numbers-p*}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end defvr

@node Private macros, Private ordinary functions, Private special variables, Internals
@subsection Macros
@deffn {Macro} {define-data-subclass} (class abbreviation)
@anchor{❨205❩}@c
@macrosubindex{define-data-subclass}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn

@node Private ordinary functions, Private generic functions, Private macros, Internals
@subsection Ordinary functions
@deffn {Function} {2d-array-to-list} (array)
@anchor{❨176❩}@c
@functionsubindex{2d-array-to-list}@c
Convert an array to a list of lists
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {add-key!} (ordered-keys key)
@anchor{❨194❩}@c
@functionsubindex{add-key!}@c
Modify ORDERED-KEYS by adding KEY.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {add-keys} (ordered-keys &rest keys)
@anchor{❨214❩}@c
@functionsubindex{add-keys}@c
Add KEYS to ORDERED-KEYS
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {aesthetic-string} (thing)
@anchor{❨152❩}@c
@functionsubindex{aesthetic-string}@c
Return the string used to represent `thing` when printing aesthetically.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨8❩, , @t{formatted-output.lisp}}.
@end table
@end deffn
@deffn {Function} {alist-data} (class alist)
@anchor{❨208❩}@c
@functionsubindex{alist-data}@c
Create an object of CLASS (subclass of DATA) from ALIST which contains key-column pairs.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Reader} {bit-variable-summary-count} (instance)
@anchor{❨173❩}@c
@functionsubindex{bit-variable-summary-count}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨69❩, , @t{count}}.
@end table
@end deffn
@deffn {Function} {bit-variable-summary-desc} (instance)
@anchor{❨165❩}@c
@functionsubindex{bit-variable-summary-desc}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {bit-variable-summary-length} (instance)
@anchor{❨223❩}@c
@functionsubindex{bit-variable-summary-length}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {bit-variable-summary-missing} (instance)
@anchor{❨134❩}@c
@functionsubindex{bit-variable-summary-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {bit-variable-summary-name} (instance)
@anchor{❨162❩}@c
@functionsubindex{bit-variable-summary-name}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {bit-variable-summary-p} (object)
@anchor{❨225❩}@c
@functionsubindex{bit-variable-summary-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {column-type-format} (sequence)
@anchor{❨154❩}@c
@functionsubindex{column-type-format}@c
Return a format string for the most specific type found in sequence
Use this for sequences of type T to determine how to format the column.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-bit-variable-summary} (instance)
@anchor{❨153❩}@c
@functionsubindex{copy-bit-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-factor-variable-summary} (instance)
@anchor{❨230❩}@c
@functionsubindex{copy-factor-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-generic-variable-summary} (instance)
@anchor{❨209❩}@c
@functionsubindex{copy-generic-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-ordered-keys} (ordered-keys)
@anchor{❨163❩}@c
@functionsubindex{copy-ordered-keys}@c
Return a copy of ORDERED-KEYS
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-real-variable-summary} (instance)
@anchor{❨156❩}@c
@functionsubindex{copy-real-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-variable-summary%} (instance)
@anchor{❨221❩}@c
@functionsubindex{copy-variable-summary%}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {df-env-p} (df)
@anchor{❨122❩}@c
@functionsubindex{df-env-p}@c
Returns T if there is environment set-up for the data frame@comma{} or NIL if there isn't one.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {df-exists-p} (s)
@anchor{❨140❩}@c
@functionsubindex{df-exists-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@end table
@end deffn
@deffn {Function} {distinct} (column)
@anchor{❨233❩}@c
@functionsubindex{distinct}@c
Returns the number of distinct elements in COLUMN@comma{} a symbol naming a variable.
Useful for formatting columns for human output
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {drop-na} (df)
@anchor{❨179❩}@c
@functionsubindex{drop-na}@c
Remove all rows from DF that are missing values.  Convenience R-like function.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨12❩, , @t{missing.lisp}}.
@end table
@end deffn
@deffn {Function} {ensure-arguments-alist} (rest)
@anchor{❨217❩}@c
@functionsubindex{ensure-arguments-alist}@c
Recognizes the following and converts them to an alist:

  plist@*
  alist@*
  (plist)@*
  (alist)@*
  (data-frame)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {ensure-not-ratio} (real)
@anchor{❨196❩}@c
@functionsubindex{ensure-not-ratio}@c
When REAL is a RATIO@comma{} convert it to a float@comma{} otherwise return as is.  Used for printing.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {factor-variable-summary-desc} (instance)
@anchor{❨143❩}@c
@functionsubindex{factor-variable-summary-desc}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Reader} {factor-variable-summary-element-count-alist} (instance)
@anchor{❨172❩}@c
@functionsubindex{factor-variable-summary-element-count-alist}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨64❩, , @t{element-count-alist}}.
@end table
@end deffn
@deffn {Function} {factor-variable-summary-length} (instance)
@anchor{❨195❩}@c
@functionsubindex{factor-variable-summary-length}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {factor-variable-summary-missing} (instance)
@anchor{❨145❩}@c
@functionsubindex{factor-variable-summary-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {factor-variable-summary-name} (instance)
@anchor{❨219❩}@c
@functionsubindex{factor-variable-summary-name}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {factor-variable-summary-p} (object)
@anchor{❨197❩}@c
@functionsubindex{factor-variable-summary-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {generic-variable-summary-desc} (instance)
@anchor{❨224❩}@c
@functionsubindex{generic-variable-summary-desc}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Reader} {generic-variable-summary-element-count-alist} (instance)
@anchor{❨193❩}@c
@functionsubindex{generic-variable-summary-element-count-alist}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨59❩, , @t{element-count-alist}}.
@end table
@end deffn
@deffn {Function} {generic-variable-summary-length} (instance)
@anchor{❨211❩}@c
@functionsubindex{generic-variable-summary-length}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {generic-variable-summary-missing} (instance)
@anchor{❨234❩}@c
@functionsubindex{generic-variable-summary-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {generic-variable-summary-name} (instance)
@anchor{❨139❩}@c
@functionsubindex{generic-variable-summary-name}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {generic-variable-summary-p} (object)
@anchor{❨220❩}@c
@functionsubindex{generic-variable-summary-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Reader} {generic-variable-summary-quantiles} (instance)
@anchor{❨202❩}@c
@functionsubindex{generic-variable-summary-quantiles}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨58❩, , @t{quantiles}}.
@end table
@end deffn
@deffn {Function} {get-type} (x)
@anchor{❨166❩}@c
@functionsubindex{get-type}@c
Return the most specific type symbol for x
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨4❩, , @t{utils.lisp}}.
@end table
@end deffn
@deffn {Function} {invalid-df-name} (s)
@anchor{❨178❩}@c
@functionsubindex{invalid-df-name}@c
A user prompt@comma{} using DUOLOGUE@comma{} to select a valid data frame name.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@end table
@end deffn
@deffn {Function} {key-index} (ordered-keys key)
@anchor{❨215❩}@c
@functionsubindex{key-index}@c
Return the index for KEY.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {key-list} (data form)
@anchor{❨155❩}@c
@functionsubindex{key-list}@c
Return a list of keys used in REST@comma{} a form
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨13❩, , @t{filter.lisp}}.
@end table
@end deffn
@deffn {Function} {keys-count} (ordered-keys)
@anchor{❨144❩}@c
@functionsubindex{keys-count}@c
Number of keys.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {keys-vector} (ordered-keys)
@anchor{❨124❩}@c
@functionsubindex{keys-vector}@c
Vector of all keys.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {make-bit-variable-summary} (&key length missing name desc count)
@anchor{❨167❩}@c
@functionsubindex{make-bit-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {make-data} (class keys columns)
@anchor{❨138❩}@c
@functionsubindex{make-data}@c
Create a DATA object from KEYS and COLUMNS.  FOR INTERNAL USE.  Always creates a copy of COLUMNS in order to ensure that it is an adjustable array with a fill pointer.  KEYS are converted to ORDERED-KEYS if necessary.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {make-factor-variable-summary} (&key length missing name desc element-count-alist)
@anchor{❨204❩}@c
@functionsubindex{make-factor-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {make-generic-variable-summary} (&key length missing name desc quantiles element-count-alist)
@anchor{❨207❩}@c
@functionsubindex{make-generic-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {make-ordered-keys} (&key table)
@anchor{❨229❩}@c
@functionsubindex{make-ordered-keys}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {make-real-variable-summary} (&key length missing name desc min q25 q50 mean q75 max)
@anchor{❨159❩}@c
@functionsubindex{make-real-variable-summary}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {make-variable-summary%} (&key length missing name desc)
@anchor{❨168❩}@c
@functionsubindex{make-variable-summary%}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {max-decimal} (sequence &optional max-digits)
@anchor{❨181❩}@c
@functionsubindex{max-decimal}@c
Return the maximum number of digits to the right of the decimal point in the numbers of SEQUENCE@comma{} equal to or less than MAX-DIGITS
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {max-width} (sequence &optional max-width)
@anchor{❨199❩}@c
@functionsubindex{max-width}@c
Return the largest printed string size of the elements of SEQUENCE@comma{} equal to or less than MAX-WIDTH
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {monotonicp} (column)
@anchor{❨180❩}@c
@functionsubindex{monotonicp}@c
Returns t if all elements of COLUMN@comma{} a SYMBOL@comma{} are increasing monotonically
Useful for detecting row numbers in imported data
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {ordered-keys} (keys)
@anchor{❨226❩}@c
@functionsubindex{ordered-keys}@c
Create an ORDERED-KEYS object from KEYS (a sequence).
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {ordered-keys-p} (object)
@anchor{❨186❩}@c
@functionsubindex{ordered-keys-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Reader} {ordered-keys-table} (instance)
@anchor{❨169❩}@c
@functionsubindex{ordered-keys-table}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Target Slot
@ref{❨228❩, , @t{table}}.
@end table
@end deffn
@deffn {Function} {plist-data} (class plist)
@anchor{❨158❩}@c
@functionsubindex{plist-data}@c
Create an object of CLASS (subclass of DATA) from PLIST which contains keys and columns@comma{} interleaved.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {print-count-and-percentage} (stream count length)
@anchor{❨235❩}@c
@functionsubindex{print-count-and-percentage}@c
Print COUNT as is and also as a rounded percentage
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {print-table} (rows &optional stream)
@anchor{❨185❩}@c
@functionsubindex{print-table}@c
Print ROWS as a nicely-formatted table.@*
  Each row should have the same number of colums.@*
  Columns will be justified properly to fit the longest item in each one.
  Example:@*
    (print-table '((1 :red something)@*
                   (2 :green more)))@*
    =>@*
    1 | RED   | SOMETHING@*
    2 | GREEN | MORE@*
  
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨8❩, , @t{formatted-output.lisp}}.
@end table
@end deffn
@deffn {Function} {printer-status} ()
@anchor{❨183❩}@c
@functionsubindex{printer-status}@c
Print values of all the printer variables
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {real-variable-summary-desc} (instance)
@anchor{❨126❩}@c
@functionsubindex{real-variable-summary-desc}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {real-variable-summary-length} (instance)
@anchor{❨184❩}@c
@functionsubindex{real-variable-summary-length}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-max} (instance)
@anchor{❨151❩}@c
@functionsubindex{real-variable-summary-max}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨82❩, , @t{max}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-mean} (instance)
@anchor{❨188❩}@c
@functionsubindex{real-variable-summary-mean}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨80❩, , @t{mean}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-min} (instance)
@anchor{❨192❩}@c
@functionsubindex{real-variable-summary-min}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨77❩, , @t{min}}.
@end table
@end deffn
@deffn {Function} {real-variable-summary-missing} (instance)
@anchor{❨125❩}@c
@functionsubindex{real-variable-summary-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {real-variable-summary-name} (instance)
@anchor{❨210❩}@c
@functionsubindex{real-variable-summary-name}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {real-variable-summary-p} (object)
@anchor{❨231❩}@c
@functionsubindex{real-variable-summary-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-q25} (instance)
@anchor{❨218❩}@c
@functionsubindex{real-variable-summary-q25}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨78❩, , @t{q25}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-q50} (instance)
@anchor{❨182❩}@c
@functionsubindex{real-variable-summary-q50}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨79❩, , @t{q50}}.
@end table
@end deffn
@deffn {Reader} {real-variable-summary-q75} (instance)
@anchor{❨198❩}@c
@functionsubindex{real-variable-summary-q75}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨81❩, , @t{q75}}.
@end table
@end deffn
@deffn {Function} {remove-columns!} (data &rest keys)
@anchor{❨141❩}@c
@functionsubindex{remove-columns!}@c
Modify DATA (a data-frame or data-vector) by removing columns with keys.
If a data-frame environment exists@comma{} add columns to it as well.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {remove-key!} (ordered-keys key)
@anchor{❨203❩}@c
@functionsubindex{remove-key!}@c
Modify ORDERED-KEYS by removing KEY.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@end table
@end deffn
@deffn {Function} {reverse-df} (df)
@anchor{❨206❩}@c
@functionsubindex{reverse-df}@c
Return DF with columns in reverse order
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@deffn {Function} {show-properties} (df)
@anchor{❨216❩}@c
@functionsubindex{show-properties}@c
Show the standard properties of the variables of the data frame DF
Standard properties are 'label'@comma{} 'type' and 'unit'
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨11❩, , @t{properties.lisp}}.
@end table
@end deffn
@deffn {Function} {show-symbols} (pkg)
@anchor{❨164❩}@c
@functionsubindex{show-symbols}@c
Print all symbols in PKG
Example: (show-symbols 'mtcars)
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨10❩, , @t{defdf.lisp}}.
@end table
@end deffn
@deffn {Function} {summarize-factor-variable} (column)
@anchor{❨121❩}@c
@functionsubindex{summarize-factor-variable}@c
Return an alist of factor/count pairs
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {summarize-generic-variable} (column &optional name)
@anchor{❨142❩}@c
@functionsubindex{summarize-generic-variable}@c
Return an object that summarizes COLUMN of a DATA-FRAME.  Primarily intended for printing@comma{} not analysis@comma{} returned values should print nicely.  This function can be used on any type of column@comma{} even one with mixed types
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {summarize-real-variable} (column)
@anchor{❨222❩}@c
@functionsubindex{summarize-real-variable}@c
Return a summary for a float variable
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {types-in-column} (seq)
@anchor{❨157❩}@c
@functionsubindex{types-in-column}@c
Return a list of the types found in SEQ
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨4❩, , @t{utils.lisp}}.
@end table
@end deffn
@deffn {Reader} {variable-summary%-desc} (instance)
@anchor{❨187❩}@c
@functionsubindex{variable-summary%-desc}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨150❩, , @t{desc}}.
@end table
@end deffn
@deffn {Reader} {variable-summary%-length} (instance)
@anchor{❨189❩}@c
@functionsubindex{variable-summary%-length}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨147❩, , @t{length}}.
@end table
@end deffn
@deffn {Reader} {variable-summary%-missing} (instance)
@anchor{❨232❩}@c
@functionsubindex{variable-summary%-missing}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨148❩, , @t{missing}}.
@end table
@end deffn
@deffn {Reader} {variable-summary%-name} (instance)
@anchor{❨175❩}@c
@functionsubindex{variable-summary%-name}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Target Slot
@ref{❨149❩, , @t{name}}.
@end table
@end deffn
@deffn {Function} {variable-summary%-p} (object)
@anchor{❨200❩}@c
@functionsubindex{variable-summary%-p}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@end table
@end deffn
@deffn {Function} {weave} (&rest lists)
@anchor{❨177❩}@c
@functionsubindex{weave}@c
Return a list whose elements alternate between each of the lists
`lists`. Weaving stops when any of the lists has been exhausted.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨8❩, , @t{formatted-output.lisp}}.
@end table
@end deffn

@node Private generic functions, Private conditions, Private ordinary functions, Internals
@subsection Generic functions
@deffn {Generic Function} {check-column-compatibility} (data column)
@anchor{❨135❩}@c
@genericsubindex{check-column-compatibility}@c
Check if COLUMN is compatible with DATA.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Methods
@deffn {Method} {check-column-compatibility} ((data @ref{❨47❩, , @t{data-frame}}) column)
@anchor{❨136❩}@c
@methodsubindex{check-column-compatibility}@c
@table @strong
@end table
@end deffn
@deffn {Method} {check-column-compatibility} ((data @ref{❨127❩, , @t{data}}) column)
@anchor{❨137❩}@c
@methodsubindex{check-column-compatibility}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {column-length} (column)
@anchor{❨190❩}@c
@genericsubindex{column-length}@c
Return the length of column.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Methods
@deffn {Method} {column-length} ((column @t{vector}))
@anchor{❨191❩}@c
@methodsubindex{column-length}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Reader} {data-size} (condition)
@anchor{❨170❩}@c
@genericsubindex{data-size}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Reader Method} {data-size} ((condition @ref{❨35❩, , @t{large-data}}))
@anchor{❨171❩}@c
@methodsubindex{data-size}@c
@table @strong
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Target Slot
@ref{❨36❩, , @t{data-size}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {default-column-formats} (array)
@anchor{❨212❩}@c
@genericsubindex{default-column-formats}@c
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Methods
@deffn {Method} {default-column-formats} ((array @t{simple-array}))
@anchor{❨213❩}@c
@methodsubindex{default-column-formats}@c
Return a list of formatting strings for ARRAY@*
The method returns a set of default formatting strings using heuristics.
@table @strong
@item Source
@ref{❨7❩, , @t{pprint.lisp}}.
@end table
@end deffn
@end table
@end deffn

@node Private conditions, Private structures, Private generic functions, Internals
@subsection Conditions
@deftp {Condition} {data-frame-exists}
@anchor{❨160❩}@c
@conditionsubindex{data-frame-exists}@c
An attempt to redefine an existing data frame.  Triggered if either the symbol is bound or the package exists.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Direct superclasses
@t{error}.
@item Direct methods
@ref{❨46❩, , @t{data-frame}}.
@item Direct slots
@defvr {Slot} {data-frame}
@anchor{❨161❩}@c
@slotsubindex{data-frame}@c
@table @strong
@item Initargs
@t{:data-frame}
@item Readers
@ref{❨46❩, , @t{data-frame}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {missing-data}
@anchor{❨131❩}@c
@conditionsubindex{missing-data}@c
A variable has missing data@comma{} e.g. :na@comma{} nil
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨5❩, , @t{conditions.lisp}}.
@item Direct superclasses
@t{error}.
@item Direct slots
@defvr {Slot} {name}
@anchor{❨132❩}@c
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} {data}
@anchor{❨133❩}@c
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@end table
@end deftp

@node Private structures, Private classes, Private conditions, Internals
@subsection Structures
@deftp {Structure} {ordered-keys}
@anchor{❨227❩}@c
@structuresubindex{ordered-keys}@c
Representation of ordered keys@*
Ordered keys provide a mapping from column keys (symbols) to nonnegative
integers.  They are used internally and the corresponding interface is
NOT EXPORTED.@*

TABLE maps keys to indexes@comma{} starting from zero.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct methods
@itemize @bullet
@item
@ref{❨285❩, , @t{axis-dimension}}.
@item
@ref{❨284❩, , @t{canonical-representation}}.
@item
@ref{❨282❩, , @t{print-object}}.
@item
@ref{❨283❩, , @t{select}}.
@end itemize
@item Direct slots
@defvr {Slot} {table}
@anchor{❨228❩}@c
@slotsubindex{table}@c
@table @strong
@item Type
@t{hash-table}
@item Initform
@t{(make-hash-table :test (function eq))}
@item Readers
@ref{❨169❩, , @t{ordered-keys-table}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {variable-summary%}
@anchor{❨146❩}@c
@structuresubindex{variable-summary%}@c
Base class for summarizing variables.  Summary functions take SYMBOLs@comma{} rather than values@comma{} because the symbol property lists naming the variables have meta-data@comma{} e.g. type@comma{} label@comma{} that we want to print.  Not exported.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨9❩, , @t{summary.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨68❩, , @t{bit-variable-summary}}.
@item
@ref{❨63❩, , @t{factor-variable-summary}}.
@item
@ref{❨57❩, , @t{generic-variable-summary}}.
@item
@ref{❨76❩, , @t{real-variable-summary}}.
@end itemize
@item Direct slots
@defvr {Slot} {length}
@anchor{❨147❩}@c
@slotsubindex{length}@c
@table @strong
@item Package
@t{common-lisp}.
@item Type
@t{alexandria:array-index}
@item Initform
@t{0}
@item Readers
@ref{❨189❩, , @t{variable-summary%-length}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {missing}
@anchor{❨148❩}@c
@slotsubindex{missing}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{0}
@item Readers
@ref{❨232❩, , @t{variable-summary%-missing}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {name}
@anchor{❨149❩}@c
@slotsubindex{name}@c
@table @strong
@item Type
@t{string}
@item Initform
@t{""}
@item Readers
@ref{❨175❩, , @t{variable-summary%-name}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {desc}
@anchor{❨150❩}@c
@slotsubindex{desc}@c
@table @strong
@item Type
@t{string}
@item Initform
@t{""}
@item Readers
@ref{❨187❩, , @t{variable-summary%-desc}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp

@node Private classes, , Private structures, Internals
@subsection Classes
@deftp {Class} {data}
@anchor{❨127❩}@c
@classsubindex{data}@c
This class is used for implementing both data-vector and data-frame@comma{} and represents an ordered collection of key-column pairs.  Columns are not assumed to have any specific attributes.  This class is not exported.
@table @strong
@item Package
@ref{❨14❩, , @t{data-frame}}.
@item Source
@ref{❨6❩, , @t{data-frame.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨47❩, , @t{data-frame}}.
@item
@ref{❨43❩, , @t{data-vector}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨278❩, , @t{as-alist}}.
@item
@ref{❨137❩, , @t{check-column-compatibility}}.
@item
@ref{❨279❩, , @t{element-type}}.
@item
@ref{❨32❩, , @t{(setf name)}}.
@item
@ref{❨30❩, , @t{name}}.
@end itemize
@item Direct slots
@defvr {Slot} {name}
@anchor{❨128❩}@c
@slotsubindex{name}@c
The name of the data frame.  MUST be the same as the symbol whose value cell points to this data frame.  This slot essentially allows us to go 'backwards' and get the symbol that names the data frame.
@table @strong
@item Type
@t{string}
@item Initargs
@t{nil}
@item Readers
@ref{❨30❩, , @t{name}}.
@item Writers
@ref{❨32❩, , @t{(setf name)}}.
@end table
@end defvr
@defvr {Slot} {ordered-keys}
@anchor{❨129❩}@c
@slotsubindex{ordered-keys}@c
@table @strong
@item Type
@t{data-frame::ordered-keys}
@item Initargs
@t{:ordered-keys}
@end table
@end defvr
@defvr {Slot} {columns}
@anchor{❨130❩}@c
@slotsubindex{columns}@c
@table @strong
@item Type
@t{vector}
@item Initargs
@t{:columns}
@end table
@end defvr
@end table
@end deftp



@c ====================================================================
@c Indexes
@c ====================================================================
@node Indexes, , Definitions, Top
@appendix Indexes
@menu
* Concept index::
* Function index::
* Variable index::
* Data type index::
@end menu


@c -------------
@c Concept index
@c -------------
@node Concept index, Function index, Indexes, Indexes
@appendixsec Concepts
@printindex cp

@page


@c --------------
@c Function index
@c --------------
@node Function index, Variable index, Concept index, Indexes
@appendixsec Functions
@printindex fn

@page


@c --------------
@c Variable index
@c --------------
@node Variable index, Data type index, Function index, Indexes
@appendixsec Variables
@printindex vr

@page


@c ---------------
@c Data type index
@c ---------------
@node Data type index, , Variable index, Indexes
@appendixsec Data types
@printindex tp

@bye

@c data-frame.texi ends here
